# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'test3.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import cv2
import argparse
import random
import torch
import numpy as np
import torch.backends.cudnn as cudnn
import math
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QFile, QThread, QMutex, pyqtSignal
from utils.torch_utils import select_device
from models.experimental import attempt_load
from utils.general import check_img_size, non_max_suppression, scale_coords
from utils.datasets import letterbox
from utils.plots import plot_one_box
import pyautogui
import yaml
from pykeyboard import PyKeyboard  # 模拟键盘所使用的包
import time  # 连续进行两个动作可能太快而效果不明显，因此加入暂停时间

k = PyKeyboard()  # 键盘的实例k
ScreenWidth, ScreenHeight = pyautogui.size()

qmut_1 = QMutex()  # 创建线程锁
qmut_2 = QMutex()
control_start = False  # 控制启动标志
Sf = [False, False, False]  # 5, fist, V
Hand_Type = ['null', 'null', 'null', 'null', 'null']  # 手势滑动窗口消抖
coordinate = [(0, 0), (0, 0), (0, 0), (0, 0)]  # 列表存四个坐标 ，一个目标时[2],[3]有效
target_type = ["null", "null"]  # 一个目标时[1]有效
control_model = 0  # 控制模式


class Thread_1(QThread):  # 线程1
    capture = (320, 240)  # 输出图像中点
    coordinateOld_1 = capture
    coordinateOld_2 = capture
    coordinate_center_old = capture  # 注意应为中心点
    operate = True  # 操作生效标志位
    window_length = len(Hand_Type)
    window_local = 0
    ready2exit = False  # Esc的启动标志
    ESC_stable = 0  # Esc的消抖
    First_hand_direction = ''

    def __init__(self):
        super().__init__()

    def distence(self, a, b):
        infer_x = a[0] - b[0]
        infer_y = a[1] - b[1]
        return math.sqrt(infer_x ** 2 + infer_y ** 2)  # 中心点直线距离

    def calculate_center(self, point_1, point_2):
        centerPoint = ((point_1[0] + point_2[0]) / 2, (point_1[1] + point_2[1]) / 2)
        return centerPoint

    # 传入的坐标为左上和右下，不是需要的中心点
    def receive_code(self, Type='null', count=1):
        # 遍历刷新列表
        item = 0
        type_result = "null"
        Hand_position_chang = False
        # --------------------------------------手势滑动窗口，窗口更新
        if self.window_local < self.window_length:
            Hand_Type[self.window_local] = Type
            self.window_local += 1
        else:
            self.window_local = 0
        # 统计数量，消抖
        Hand_Set = set(Hand_Type)
        for val in Hand_Set:
            item_old = item
            item = max(Hand_Type.count(val), item)
            if item != item_old:
                type_result = val  # 此处没有处理数量相同情况,也没有处理双目标类型不一致问题。考虑建立目标类来解决
        # ---------------------------------------------------------------------参数计算
        # 首先计算中心点 ---------------------------------------------------------------------
        coordinate_center = self.calculate_center(coordinate[2], coordinate[3])
        self.coordinate_center_old = self.calculate_center(coordinate[0], coordinate[1])
        # 计算中心点相关距离 ------------------------------------------------------------------
        dis = self.distence(coordinate_center, self.coordinate_center_old)  # 中点距离
        diagonal_new = self.distence(a=coordinate[2], b=coordinate_center)  # 中点到某角距离
        diagonal_old = self.distence(a=coordinate[0], b=self.coordinate_center_old)  # 中点到某角距离
        # 计算IOU -----------------------------------------------------------------------------------
        width = min(coordinate[1][0], coordinate[3][0]) - max(coordinate[0][0], coordinate[2][0])
        high = min(coordinate[1][1], coordinate[3][1]) - max(coordinate[0][1], coordinate[2][1])
        # 交集 --------------------------------------------------------------------------------------
        intersection = width * high
        targetRectangleNew = (coordinate[3][0] - coordinate[2][0]) * (coordinate[3][1] - coordinate[2][1])
        targetRectangleOld = (coordinate[1][0] - coordinate[0][0]) * (coordinate[1][1] - coordinate[0][1])
        # 并集 --------------------------------------------------------------------------------------
        union = targetRectangleNew + targetRectangleOld - intersection
        if diagonal_new + diagonal_old <= dis:  # 三角形两边之和大于第三边
            IOU = 0
        else:
            IOU = intersection / union
            Hand_position_chang = True if IOU < 0.37 else False
        # ---------------------------------------------------------------------至此，移动判定结束
        # 计算两次坐标位移夹角
        inference_1 = abs(coordinate_center[0] - self.coordinate_center_old[0])
        inference_2 = abs(coordinate_center[1] - self.coordinate_center_old[1])
        if inference_1 != 0:
            division = inference_2 / inference_1  # 注意分母为0
            angle = math.degrees(math.atan(division))
        else:
            angle = 0
        # ---------------------------------------------------------------------翻页功能实现
        # 此处应该再加入定长时间内允许操作次数
        if control_model == 0:
            if type_result == '5':
                self.ready2exit = True
            if count == 1:  # 一个手，判断为翻页
                if type_result == '5' and abs(angle) < 50 and Hand_position_chang:
                    direction = coordinate_center[0] - self.coordinate_center_old[0]  # 移动方向
                    if direction > 0:
                        k.press_key(33)  # 模拟键盘按PgUp键
                        time.sleep(0.01)
                        k.release_key(33)  # 模拟键盘松开PgUp键
                    elif direction < 0:
                        k.press_key(34)  # 模拟键盘按PgDn键
                        time.sleep(0.01)
                        k.release_key(34)  # 模拟键盘松开PgDn键
            elif count == 2:
                if type_result == '5' and abs(angle) < 50:  # 预放映状态，似乎缺少状态切换瞬间的消抖
                    infer = abs(coordinate_center[0] - self.coordinate_center_old[0])
                    if 20 < infer < 100:  # 20<, 有误检抖动时，其中心点差距很小，借此消抖
                        k.press_key(16)  # 模拟键盘按shift键
                        k.press_key(116)  # 模拟键盘按F5键
                        time.sleep(0.01)
                        k.press_key(116)  # 模拟键盘按F5键
                        k.release_key(16)  # 模拟键盘松开shift键
            # -----------------------------------------------------------------------退出功能实现
            if self.ready2exit:
                if self.ESC_stable % 3 == 0:
                    if type_result == 'Fist':
                        k.press_key(27)
                        time.sleep(0.01)
                        k.release_key(27)
                        self.ready2exit = False
                    elif type_result == 'v':  # 从头放映
                        k.press_key(116)
                        time.sleep(0.01)
                        k.release_key(116)
                        self.ready2exit = False
                self.ESC_stable += 1
            if self.ESC_stable == 100:
                self.ESC_stable = 0
        # -----------------------------------------------------------------------第二个控制模式
        elif control_model == 1:
            if type_result == '5':
                self.ready2exit = True
            if count == 1:  # 一个手，判断为翻页
                self.First_hand_direction = ''
                if type_result == '5' and abs(angle) < 50 and Hand_position_chang:
                    direction = coordinate_center[0] - self.coordinate_center_old[0]  # 移动方向
                    if direction > 0:
                        k.press_key(33)  # 模拟键盘按PgUp键
                        time.sleep(0.01)
                        k.release_key(33)  # 模拟键盘松开PgUp键
                    elif direction < 0:
                        k.press_key(34)  # 模拟键盘按PgDn键
                        time.sleep(0.01)
                        k.release_key(34)  # 模拟键盘松开PgDn键
            elif count == 2:  # 双手手势
                if type_result == '5' and abs(angle) < 50:  # 预放映状态，似乎缺少状态切换瞬间的消抖
                    infer = abs(coordinate_center[0] - self.coordinate_center_old[0])
                    if 20 < infer < 100:  # 20<, 有误检抖动时，其中心点差距很小，借此消抖
                        k.press_key(17)  # 模拟键盘按ctrl键
                        k.press_key(107)  # 模拟键盘按F5键
                        time.sleep(0.01)
                        k.press_key(107)  # 模拟键盘按F5键
                        k.release_key(17)  # 模拟键盘松开ctrl键
                    elif infer > 300:
                        k.press_key(17)  # 模拟键盘按ctrl键
                        k.press_key(109)  # 模拟键盘按F5键
                        time.sleep(0.01)
                        k.press_key(109)  # 模拟键盘按F5键
                        k.release_key(17)  # 模拟键盘松开ctrl键
            # --------------------------------------------------------------------退出与开始功能实现
            if self.ready2exit:
                if self.ESC_stable % 3 == 0:
                    if type_result == 'Fist':
                        k.press_key(27)
                        time.sleep(0.01)
                        k.release_key(27)
                        self.ready2exit = False
                    elif type_result == 'v':  # 从头放映
                        k.press_key(122)
                        time.sleep(0.01)
                        k.release_key(122)
                        self.ready2exit = False
                self.ESC_stable += 1
            if self.ESC_stable == 100:
                self.ESC_stable = 0


class Ui_MainWindow(QtWidgets.QMainWindow):

    def __init__(self, parent=None):
        super(Ui_MainWindow, self).__init__(parent)
        self.timer_video = QtCore.QTimer()
        self.setupUi(self)
        self.init_logo()
        self.init_slots()
        self.cap = cv2.VideoCapture()

        parser = argparse.ArgumentParser()
        parser.add_argument('--weights', nargs='+', type=str,
                            default='../runs/train/exp9_weight_m_CBAM_160/exp9/weights/best.pt', help='model.pt path(s)')
        parser.add_argument('--source', type=str, default='0', help='source')
        parser.add_argument('--img-size', type=int, default=640, help='inference size (pixels)')
        parser.add_argument('--conf-thres', type=float, default=0.25, help='object confidence threshold')
        parser.add_argument('--iou-thres', type=float, default=0.45, help='IOU threshold for NMS')
        parser.add_argument('--device', default='', help='cuda device, i.e. 0 or 0,1,2,3 or cpu')
        parser.add_argument('--view-img', action='store_true', help='display results')
        parser.add_argument('--save-txt', action='store_true', help='save results to *.txt')
        parser.add_argument('--save-conf', action='store_true', help='save confidences in --save-txt labels')
        parser.add_argument('--nosave', action='store_true', help='do not save images/videos')
        parser.add_argument('--classes', nargs='+', type=int, help='filter by class: --class 0, or --class 0 2 3')
        parser.add_argument('--agnostic-nms', action='store_true', help='class-agnostic NMS')
        parser.add_argument('--augment', action='store_true', help='augmented inference')
        parser.add_argument('--update', action='store_true', help='update all models')
        parser.add_argument('--project', default='runs/detect', help='save results to project/name')
        parser.add_argument('--name', default='exp', help='save results to project/name')
        parser.add_argument('--exist-ok', action='store_true', help='existing project/name ok, do not increment')
        self.opt = parser.parse_args()
        print(self.opt)

        source, weights, view_img, save_txt, imgsz = self.opt.source, self.opt.weights, self.opt.view_img, self.opt.save_txt, self.opt.img_size

        self.device = select_device(self.opt.device)
        self.half = self.device.type != 'cpu'  # half precision only supported on CUDA

        cudnn.benchmark = True

        # Load model
        self.model = attempt_load(
            weights, map_location=self.device)  # load FP32 model
        stride = int(self.model.stride.max())  # model stride
        self.imgsz = check_img_size(imgsz, s=stride)  # check img_size
        if self.half:
            self.model.half()  # to FP16

        # Get names and colors
        self.names = self.model.module.names if hasattr(
            self.model, 'module') else self.model.names
        self.colors = [[random.randint(0, 255)
                        for _ in range(3)] for _ in self.names]

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(340, 369)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setEnabled(True)
        self.label.setMinimumSize(QtCore.QSize(320, 240))
        self.label.setMaximumSize(QtCore.QSize(320, 240))
        self.label.setObjectName("label")
        self.verticalLayout_2.addWidget(self.label)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lcdNumber = QtWidgets.QLCDNumber(self.centralwidget)
        self.lcdNumber.setSegmentStyle(QtWidgets.QLCDNumber.Flat)
        self.lcdNumber.setObjectName("lcdNumber")
        self.horizontalLayout_2.addWidget(self.lcdNumber)
        self.horizontalSlider = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider.setMaximum(4)
        self.horizontalSlider.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider.setObjectName("horizontalSlider")
        self.horizontalLayout_2.addWidget(self.horizontalSlider)
        self.lcdNumber_2 = QtWidgets.QLCDNumber(self.centralwidget)
        self.lcdNumber_2.setSegmentStyle(QtWidgets.QLCDNumber.Flat)
        self.lcdNumber_2.setObjectName("lcdNumber_2")
        self.horizontalLayout_2.addWidget(self.lcdNumber_2)
        self.horizontalSlider_2 = QtWidgets.QSlider(self.centralwidget)
        self.horizontalSlider_2.setMaximum(4)
        self.horizontalSlider_2.setOrientation(QtCore.Qt.Horizontal)
        self.horizontalSlider_2.setObjectName("horizontalSlider_2")
        self.horizontalLayout_2.addWidget(self.horizontalSlider_2)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout.addWidget(self.pushButton)
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setObjectName("pushButton_2")
        self.horizontalLayout.addWidget(self.pushButton_2)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.horizontalLayout_3.addLayout(self.verticalLayout_2)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 340, 23))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.horizontalSlider.valueChanged['int'].connect(self.lcdNumber.display)
        self.horizontalSlider_2.valueChanged['int'].connect(self.lcdNumber_2.display)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "手势会议控制"))
        self.label.setText(_translate("MainWindow", "此处显示相机画面"))
        self.pushButton.setText(_translate("MainWindow", "开启相机"))
        self.pushButton_2.setText(_translate("MainWindow", "开启控制"))

    def init_slots(self):
        self.pushButton.clicked.connect(self.Start_Cam)
        self.timer_video.timeout.connect(self.show_video_frame)
        self.pushButton_2.clicked.connect(self.click_1)  # 绑定槽函数

    def init_logo(self):
        img_path = "../icon/cover.jpg"
        self.label.setScaledContents(True)
        self.label.setPixmap(QtGui.QPixmap(img_path))

    def click_1(self):
        global control_start
        control_start = True
        screenWidth, screenHeight = pyautogui.size()
        print("当前分辨率 : ", screenWidth, '*', screenHeight)
        # 获取当前鼠标位置
        currentMouseX, currentMouseY = pyautogui.position()
        print("当前位置 : X = ", currentMouseX, 'Y = ', currentMouseY)
        pyautogui.moveTo(screenWidth / 2, screenHeight / 2)
        pyautogui.click()
        print("goto screen center")
        self.thread_1 = Thread_1()  # 创建线程
        self.thread_1.start()  # 开始线程

    def Start_Cam(self):
        if not self.timer_video.isActive():
            # 默认使用第一个本地camera
            global control_model
            control_model = int(self.lcdNumber_2.value())
            flag = self.cap.open(int(self.lcdNumber.value()))
            if not flag:
                QtWidgets.QMessageBox.warning(self, u"Warning", u"打开摄像头失败", buttons=QtWidgets.QMessageBox.Ok,
                                              defaultButton=QtWidgets.QMessageBox.Ok)
            else:
                self.timer_video.start(30)
                self.pushButton.setText(u"关闭摄像头")
        else:
            self.timer_video.stop()
            self.cap.release()
            self.label.clear()
            self.init_logo()
            self.pushButton.setText(u"摄像头检测")

    def show_video_frame(self):
        name_list = []
        # ---------------------自定义部分
        ex = False
        direct = ['null', 'null']
        # ---------------------自定义部分
        flag, img = self.cap.read()
        if img is not None:
            showimg = img
            img = letterbox(img, new_shape=self.opt.img_size)[0]
            # Convert
            # BGR to RGB, to 3x416x416
            img = img[:, :, ::-1].transpose(2, 0, 1)
            img = np.ascontiguousarray(img)
            img = torch.from_numpy(img).to(self.device)
            img = img.half() if self.half else img.float()  # uint8 to fp16/32
            img /= 255.0  # 0 - 255 to 0.0 - 1.0
            if img.ndimension() == 3:
                img = img.unsqueeze(0)
            # Inference
            pred = self.model(img, augment=self.opt.augment)[0]

            # Apply NMS
            pred = non_max_suppression(pred, self.opt.conf_thres, self.opt.iou_thres, classes=self.opt.classes,
                                       agnostic=self.opt.agnostic_nms)
            # Process detections
            for i, det in enumerate(pred):  # detections per image
                if det is not None and len(det):
                    # Rescale boxes from img_size to im0 size
                    det[:, :4] = scale_coords(
                        img.shape[2:], det[:, :4], showimg.shape).round()
                    # Write results
                    for *xyxy, conf, cls in reversed(det):
                        label = '%s %.2f' % (self.names[int(cls)], conf)  # 类型与置信度
                        name_list.append(self.names[int(cls)])
                        print(label)
                        coordinate[0], coordinate[1] = coordinate[2], coordinate[3]
                        target_type[0] = target_type[1]
                        coordinate[2], coordinate[3], ex, target_type[1] = plot_one_box(
                            xyxy, showimg, label=label, color=self.colors[int(cls)], line_thickness=2)
            print("[目标数量] = ", det.shape[0])
            if ex and control_start:
                self.thread_1.receive_code(Type=target_type[1].strip(' ').split()[0], count=det.shape[0])
            elif not ex:
                print("[ No Target ]")
            show = cv2.resize(showimg, (640, 480))  # 输出视频大小
            self.result = cv2.cvtColor(show, cv2.COLOR_BGR2RGB)
            showImage = QtGui.QImage(self.result.data, self.result.shape[1], self.result.shape[0],
                                     QtGui.QImage.Format_RGB888)
            self.label.setPixmap(QtGui.QPixmap.fromImage(showImage))  # 显示视频帧
        else:
            self.timer_video.stop()
            self.cap.release()
            self.label.clear()
            self.pushButton.setDisabled(False)


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    ui = Ui_MainWindow()
    ui.show()
    sys.exit(app.exec_())
